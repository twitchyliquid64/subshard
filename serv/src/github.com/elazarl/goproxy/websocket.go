package goproxy

import (
	"net"
	"net/http"
	"strings"
	"sync/atomic"
)

//isWebSocketRequest returns a boolean indicating whether the request has the
// headers of a WebSocket handshake request.
func isWebSocketRequest(r *http.Request) bool {
	contains := func(key, val string) bool {
		vv := strings.Split(r.Header.Get(key), ",")
		for _, v := range vv {
			if val == strings.ToLower(strings.TrimSpace(v)) {
				return true
			}
		}
		return false
	}
	if !contains("Connection", "upgrade") {
		return false
	}
	if !contains("Upgrade", "websocket") {
		return false
	}
	return true
}

//serveHTTPWebsocket serve only http websockets. https websockets will be handle
func (proxy *ProxyHttpServer) serveHTTPWebsocket(w http.ResponseWriter, r *http.Request) {
	// TODO use tls connection to websocket
	ctx := &ProxyCtx{Req: r, Session: atomic.AddInt64(&proxy.sess, 1), proxy: proxy}
	outreq := new(http.Request)
	// shallow copying
	r, _ = proxy.filterRequest(r, ctx)
	*outreq = *r
	host := outreq.URL.Host
	if !hasPort.MatchString(host) {
		host += ":80"
	}
	ctx.Logf("Forwarding WebSocket %v", outreq.URL.String())
	targetSiteCon, err := proxy.connectDial("tcp", host)
	if err != nil {
		http.Error(w, "Error forwarding request.", 500)
		ctx.Warnf("Error dialing websocket backend %s: %v", outreq.URL, err)
		return
	}
	// All request generated by the http package implement this interface.
	hj, ok := w.(http.Hijacker)
	if !ok {
		http.Error(w, "Not a hijacker?", 500)
		ctx.Warnf("Not a hijacker?")
		return
	}
	// Hijack() tells the http package not to do anything else with the connection.
	// After, it bcomes this functions job to manage it. `nc` is of type *net.Conn.
	proxyClient, _, err := hj.Hijack()
	if err != nil {
		ctx.Warnf("Hijack error: %v", err)
		return
	}

	// write the modified incoming request to the dialed connection
	err = outreq.Write(targetSiteCon)
	if err != nil {
		ctx.Warnf("Error copying request to target: %v", err)
		return
	}
	go copyAndClose(ctx, targetSiteCon.(*net.TCPConn), proxyClient.(*net.TCPConn))
	go copyAndClose(ctx, proxyClient.(*net.TCPConn), targetSiteCon.(*net.TCPConn))
}
